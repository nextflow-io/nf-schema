{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nf-schema","text":"<p>A Nextflow plugin to work with validation of pipeline parameters and sample sheets.</p> <p>Info</p> <p>nf-schema is the new version of the now deprecated nf-validation. Please follow the migration guide to migrate your code to this new version.</p> <p>Parameter schema specs Sample sheet schema specs</p>"},{"location":"#introduction","title":"Introduction","text":"<p>This Nextflow plugin provides functionality that can be used in a Nextflow pipeline to work with parameter and sample sheet schema. The added functionality is:</p> <ul> <li>\ud83d\udcd6 Print usage instructions to the terminal (for use with <code>--help</code>)</li> <li>\u270d\ufe0f Print log output showing parameters with non-default values</li> <li>\u2705 Validate supplied parameters against the pipeline schema</li> <li>\ud83d\udccb Validate the contents of supplied sample sheet files</li> <li>\ud83d\udee0\ufe0f Create a type-casted list from a parsed sample sheet</li> </ul> <p>Supported sample sheet formats are CSV, TSV, JSON and YAML.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Declare the plugin in your Nextflow pipeline configuration file:</p> nextflow.config<pre><code>plugins {\n  id 'nf-schema@2.4.1'\n}\n</code></pre> <p>This is all that is needed - Nextflow will automatically fetch the plugin code at run time.</p> <p>[!NOTE] The snippet above will always try to install the specified version. We encourage always pinning the plugin version to make sure the used pipeline will keep working when a new version of <code>nf-schema</code> with breaking changes has been released.</p> <p>You can now include the plugin helper functions into your Nextflow pipeline:</p> main.nf<pre><code>include { validateParameters; paramsSummaryLog; samplesheetToList } from 'plugin/nf-schema'\n\n// Validate input parameters\nvalidateParameters()\n\n// Print summary of supplied parameters\nlog.info paramsSummaryLog(workflow)\n\n// Create a new channel of metadata from a sample sheet passed to the pipeline through the --input parameter\nch_input = Channel.fromList(samplesheetToList(params.input, \"assets/schema_input.json\"))\n</code></pre> <p>Or enable the creation of the help message (using <code>--help</code>) in the configuration file:</p> nextflow.config<pre><code>validation {\n  help {\n    enabled: true\n  }\n}\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>Java 11 or later</li> <li>https://github.com/harrel56/json-schema</li> <li>Nextflow 24.10.0 or later</li> </ul>"},{"location":"#slack-channel","title":"Slack channel","text":"<p>There is a dedicated nf-schema Slack channel in the Nextflow Slack workspace.</p>"},{"location":"#credits","title":"Credits","text":"<p>This plugin was written based on code initially written within the nf-core community, as part of the nf-core pipeline template.</p> <p>We would like to thank the key contributors who include (but are not limited to):</p> <ul> <li>J\u00falia Mir Pedrol (@mirpedrol)</li> <li>Nicolas Vannieuwkerke (@nvnieuwk)</li> <li>Kevin Menden (@KevinMenden)</li> <li>Phil Ewels (@ewels)</li> <li>Arthur (@awgymer)</li> </ul>"},{"location":"background/","title":"Background","text":"<p>The Nextflow workflow manager is a powerful tool for scientific workflows. In order for end users to launch a given workflow with different input data and varying settings, pipelines are developed using a special variable type called parameters (<code>params</code>). Defaults are hardcoded into scripts and config files but can be overwritten by user config files and command-line flags (see the Nextflow docs).</p> <p>In addition to config params, a common best-practice for pipelines is to use a \"sample sheet\" file containing required input information. For example: a sample identifier, filenames and other sample-level metadata.</p> <p>Nextflow itself does not provide functionality to validate config parameters or parsed sample sheets. To bridge this gap, we developed code within the nf-core community to allow pipelines to work with a standard <code>nextflow_schema.json</code> file, written using the JSON Schema format. The file allows strict typing of parameter variables and inclusion of validation rules.</p> <p>The nf-schema plugin moves this code out of the nf-core template into a stand-alone package, to make it easier to use for the wider Nextflow community. It also incorporates a number of new features, such as native Groovy sample sheet validation.</p> <p>Earlier versions of the plugin can be found in the nf-validation repository and can still be used in the pipeline. However the nf-validation plugin is no longer supported and all development has been moved to nf-schema.</p>"},{"location":"migration_guide/","title":"Migration guide","text":"<p>Warning</p> <p><code>nf-schema</code> currently is not supported by the nf-core tooling. Using this plugin will break the linting and schema builder. See these issues for the progress on the nf-core migration to nf-schema:</p> <ol> <li>https://github.com/nf-core/tools/issues/2932</li> <li>https://github.com/nf-core/tools/issues/2784</li> <li>https://github.com/nf-core/tools/issues/2429</li> </ol> <p>This guide is intended to help you migrate your pipeline from nf-validation to nf-schema.</p>"},{"location":"migration_guide/#major-changes-in-the-plugin","title":"Major changes in the plugin","text":"<p>Following list shows the major breaking changes introduced in nf-schema:</p> <ol> <li>The JSON schema draft has been updated from <code>draft-07</code> to <code>draft-2020-12</code>. See JSON Schema draft 2020-12 release notes and JSON schema draft 2019-09 release notes for more information.</li> <li>The <code>fromSamplesheet</code> channel factory has been converted to a function called <code>samplesheetToList</code>. See updating <code>fromSamplesheet</code> for more information.</li> <li>The <code>unique</code> keyword for samplesheet schemas has been removed. Please use <code>uniqueItems</code> or <code>uniqueEntries</code> now instead.</li> <li>The <code>dependentRequired</code> keyword now works as it's supposed to work in JSON schema. See <code>dependentRequired</code> for more information.</li> <li>All configuration parameters have been converted to Nextflow configuration options. See Updating configuration for more information.</li> <li>Help messages are now created automatically instead of using the <code>paramsHelp()</code> function. (v2.1.0 feature)</li> </ol> <p>A full list of changes can be found in the changelog.</p>"},{"location":"migration_guide/#updating-your-pipeline","title":"Updating your pipeline","text":"<p>Updating your pipeline can be done in a couple simple steps.</p>"},{"location":"migration_guide/#updating-the-name-and-version-of-the-plugin","title":"Updating the name and version of the plugin","text":"<p>The name and the version of the plugin should be updated from <code>nf-validation</code> to <code>nf-schema@2.0.0</code>:</p> nf-validationnf-schema <pre><code>plugins {\n    id 'nf-validation@1.1.3'\n}\n</code></pre> <pre><code>plugins {\n    id 'nf-schema@2.0.0'\n}\n</code></pre> <p>Additionally, all includes from <code>nf-validation</code> should be updated to <code>nf-schema</code>. This can easily be done with the following command:</p> <pre><code>find . -type f -name \"*.nf\" -exec sed -i -e \"s/from 'plugin\\/nf-validation'/from 'plugin\\/nf-schema'/g\" -e 's/from \"plugin\\/nf-validation\"/from \"plugin\\/nf-schema\"/g' {} +\n</code></pre>"},{"location":"migration_guide/#updating-the-json-schema-files","title":"Updating the JSON schema files","text":"<p>If you aren't using any special features in your schemas, you can simply update your <code>nextflow_schema.json</code> file using the following command:</p> <pre><code>sed -i -e 's/https?:\\/\\/json-schema.org\\/draft-07\\/schema/https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema/g' -e 's/definitions/$defs/g' nextflow_schema.json\n</code></pre> <p>This will replace the old schema draft specification (<code>draft-07</code>) by the new one (<code>2020-12</code>), and the old keyword <code>definitions</code> by the new notation <code>$defs</code>.</p> <p>Note</p> <p>Repeat this command for every JSON schema used in your pipeline. e.g. for the default samplesheet schema in nf-core pipelines: <code>bash sed -i -e 's/https?:\\/\\/json-schema.org\\/draft-07\\/schema/https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema/g' -e 's/definitions/$defs/g' assets/schema_input.json</code></p> <p>Warning</p> <p>This will not update changes to special fields in the schema, see the guide for special JSON schema keywords on how to update these</p>"},{"location":"migration_guide/#update-the-samplesheet-conversion","title":"Update the samplesheet conversion","text":"<p>The <code>.fromSamplesheet</code> channel factory should be converted to the <code>samplesheetToList</code> function. Following tabs shows how to use the function to get the same effect as the channel factory:</p> nf-validationnf-schema <pre><code>include { fromSamplesheet } from 'plugin/nf-validation'\nChannel.fromSamplesheet(\"input\")\n</code></pre> <pre><code>include { samplesheetToList } from 'plugin/nf-schema'\nChannel.fromList(samplesheetToList(params.input, \"path/to/samplesheet/schema\"))\n</code></pre> <p>Note</p> <p>This change was necessary to make it possible for pipelines to be used as pluggable workflows. This also enables the validation and conversion of files generated by the pipeline.</p>"},{"location":"migration_guide/#updating-configuration","title":"Updating configuration","text":"<p>The configuration parameters have been converted to a Nextflow configuration option. You can now access these options using the <code>validation</code> config scope:</p> <pre><code>validation.&lt;option&gt; = &lt;value&gt;\n</code></pre> <p>OR</p> <pre><code>validation {\n    &lt;option1&gt; = &lt;value1&gt;\n    &lt;option2&gt; = &lt;value2&gt;\n}\n</code></pre> <p>See this table for an overview of what the new configuration options are for the old parameters:</p> Old parameter New config option(s) <code>params.validationMonochromeLogs = &lt;boolean&gt;</code> <code>validation.monochromeLogs = &lt;boolean&gt;</code> <code>params.validationLenientMode = &lt;boolean&gt;</code> <code>validation.lenientMode = &lt;boolean&gt;</code> <code>params.validationFailUnrecognisedParams = &lt;boolean&gt;</code> <code>validation.failUnrecognisedParams = &lt;boolean&gt;</code> <code>params.validationShowHiddenParams = &lt;boolean&gt;</code> <code>validation.showHiddenParams = &lt;boolean&gt;</code> <code>params.validationIgnoreParams = &lt;string&gt;</code> <code>validation.defaultIgnoreParams = &lt;list&gt;</code> and <code>validation.ignoreParams = &lt;list&gt;</code> <p>Note</p> <p><code>defaultIgnoreParams</code> is meant to be used by pipeline developers to set the parameters which should always be ignored. <code>ignoreParams</code> is meant for the pipeline user to ignore certain parameters.</p>"},{"location":"migration_guide/#updating-special-keywords-in-json-schemas","title":"Updating special keywords in JSON schemas","text":"<p>If you are using any special features in your schemas, you will need to update your schemas manually. Please refer to the JSON Schema draft 2020-12 release notes and JSON schema draft 2019-09 release notes for more information.</p> <p>However here are some guides to the more common migration patterns:</p>"},{"location":"migration_guide/#updating-unique-keyword","title":"Updating <code>unique</code> keyword","text":"<p>When you use <code>unique</code> in your schemas, you should update it to use <code>uniqueItems</code> or <code>uniqueEntries</code> instead.</p> <p>If you used the <code>unique:true</code> field, you should update it to use <code>uniqueItems</code> like this:</p> nf-validationnf-schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sample\": {\n                \"type\": \"string\",\n                \"unique\": true\n            }\n        }\n    }\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sample\": {\n                \"type\": \"string\"\n            }\n        }\n    },\n    \"uniqueItems\": true\n}\n</code></pre> <p>If you used the <code>unique: [\"field1\", \"field2\"]</code> field, you should update it to use <code>uniqueEntries</code> like this:</p> nf-validationnf-schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sample\": {\n                \"type\": \"string\",\n                \"unique\": [\"sample\"]\n            }\n        }\n    }\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"array\",\n    \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"sample\": {\n                \"type\": \"string\"\n            }\n        }\n    },\n    \"uniqueEntries\": [\"sample\"]\n}\n</code></pre>"},{"location":"migration_guide/#updating-dependentrequired-keyword","title":"Updating <code>dependentRequired</code> keyword","text":"<p>When you use <code>dependentRequired</code> in your schemas, you should update it like this:</p> nf-validationnf-schema <pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"fastq_1\": {\n            \"type\": \"string\",\n            \"format\": \"file-path\"\n        },\n        \"fastq_2\": {\n            \"type\": \"string\",\n            \"format\": \"file-path\",\n            \"dependentRequired\": [\"fastq_1\"]\n        }\n    }\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"type\": \"object\",\n    \"properties\": {\n        \"fastq_1\": {\n            \"type\": \"string\",\n            \"format\": \"file-path\"\n        },\n        \"fastq_2\": {\n            \"type\": \"string\",\n            \"format\": \"file-path\"\n        }\n    },\n    \"dependentRequired\": {\n        \"fastq_2\": [\"fastq_1\"]\n    }\n}\n</code></pre>"},{"location":"migration_guide/#updating-the-help-message","title":"Updating the help message","text":"<p>v2.1.0 feature</p> <p>The creation of the help message now needs to be enabled in the configuration file. Using <code>--help</code> or <code>--helpFull</code> will automatically print the help message and stop the pipeline execution. <code>paramsHelp()</code> is still available in <code>nf-schema</code> and can still be used like before. This could be helpful to print the help message in specific cases. Mind that this function now automatically emits a deprecation warning. This warning can be disabled using the <code>hideWarning:true</code> option of the function.</p> nf-validationnf-schema main.nf<pre><code>if (params.help) {\n    log.info paramsHelp(\"nextflow run my_pipeline --input input_file.csv\")\n    exit 0\n}\n</code></pre> nextflow.config<pre><code>validation {\n    help {\n        enabled = true\n        command = \"nextflow run my_pipeline --input input_file.csv\"\n    }\n}\n</code></pre>"},{"location":"configuration/configuration/","title":"Configuration","text":"<p>The plugin can be configured using several configuration options. These options have to be in the <code>validation</code> scope which means you can write them in two ways:</p> <pre><code>validation.&lt;option&gt; = &lt;value&gt;\n</code></pre> <p>OR</p> <pre><code>validation {\n    &lt;option1&gt; = &lt;value1&gt;\n    &lt;option2&gt; = &lt;value2&gt;\n}\n</code></pre>"},{"location":"configuration/configuration/#parametersschema","title":"parametersSchema","text":"<p>This option can be used to set the parameters JSON schema to be used by the plugin. This will affect parameter validation (<code>validateParameters()</code>), the summary logs (<code>paramsSummaryLog()</code> and <code>paramsSummaryMap()</code>) and the creation of the help messages.</p> <pre><code>validation.parametersSchema = \"path/to/schema.json\" // default \"nextflow_schema.json\"\n</code></pre> <p>This option can either be a path relative to the root of the pipeline directory or a full path to the JSON schema (Be wary to not use hardcoded local paths to ensure your pipeline will keep working on other systems)</p>"},{"location":"configuration/configuration/#monochromelogs","title":"monochromeLogs","text":"<p>This option can be used to turn of the colored logs from nf-validation. This can be useful if you run a Nextflow pipeline in an environment that doesn't support colored logging.</p> <pre><code>validation.monochromeLogs = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#lenientmode","title":"lenientMode","text":"<p>This option can be used to make the type validation more lenient. In normal cases a value of <code>\"12\"</code> will fail if the type is an <code>integer</code>. This will succeed in lenient mode since that string can be cast to an <code>integer</code>.</p> <pre><code>validation.lenientMode = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#failunrecognisedparams","title":"failUnrecognisedParams","text":"<p>By default the <code>validateParameters()</code> function will only give a warning if an unrecognised parameter has been given. This usually indicates that a typo has been made and can be easily overlooked when the plugin only emits a warning. You can turn this warning into an error with the <code>failUnrecognisedParams</code> option.</p> <pre><code>validation.failUnrecognisedParams = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#failunrecognisedheaders","title":"failUnrecognisedHeaders","text":"<p>By default the <code>samplesheetToList()</code> function will only give a warning if an unrecognised header is present in the samplesheet. This usually indicates that a typo has been made and can be easily overlooked when the plugin only emits a warning. You can turn this warning into an error with the <code>failUnrecognisedHeaders</code> option.</p> <pre><code>validation.failUnrecognisedHeaders = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#showhiddenparams","title":"showHiddenParams","text":"<p>Deprecated</p> <p>This configuration option has been deprecated since v2.1.0. Please use <code>validation.help.showHidden</code> instead.</p> <p>By default the parameters, that have the <code>\"hidden\": true</code> annotation in the JSON schema, will not be shown in the help message. Turning on this option will make sure the hidden parameters are also shown.</p> <pre><code>validation.showHiddenParams = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#ignoreparams","title":"ignoreParams","text":"<p>This option can be used to turn off the validation for certain parameters. It takes a list of parameter names as input. Currently, the parameter <code>nf_test_output</code> is added to <code>ignoreParams</code> by default.</p> <pre><code>validation.ignoreParams = [\"param1\", \"param2\"] // default: []\n</code></pre>"},{"location":"configuration/configuration/#defaultignoreparams","title":"defaultIgnoreParams","text":"<p>Warning</p> <p>This option should only be used by pipeline developers</p> <p>This option does exactly the same as <code>validation.ignoreParams</code>, but provides pipeline developers with a way to set the default parameters that should be ignored. This way the pipeline users don't have to re-specify the default ignored parameters when using the <code>validation.ignoreParams</code> option.</p> <pre><code>validation.defaultIgnoreParams = [\"param1\", \"param2\"] // default: []\n</code></pre>"},{"location":"configuration/configuration/#maxerrvalsize","title":"maxErrValSize","text":"<p>Configure the maximum characters of a value that may be shown in an error message. It takes a whole number above or equal to <code>1</code>. A value will be truncated when it goes over the maximum amount of characters.</p> <p>Setting this option to <code>-1</code> will allow any amount of characters for values.</p> <p>See the below example where the limit is to 20 characters:</p> <pre><code>* --test (abcdefghij...qrstuvwxyz): Value is [string] but should be [integer]\n</code></pre> <pre><code>validation.maxErrValSize = 100 // default: 150\n</code></pre>"},{"location":"configuration/configuration/#help","title":"help","text":"<p>The <code>validation.help</code> config scope can be used to configure the creation of the help message.</p> <p>This scope contains the following options:</p>"},{"location":"configuration/configuration/#enabled","title":"enabled","text":"<p>This option is used to enable the creation of the help message when the help parameters are used in the <code>nextflow run</code> command.</p> <pre><code>validation.help.enabled = true // default: false\n</code></pre>"},{"location":"configuration/configuration/#shortparameter","title":"shortParameter","text":"<p>This option can be used to change the <code>--help</code> parameter to another parameter. This parameter will print out the help message with all top level parameters.</p> <pre><code>validation.help.shortParameter = \"giveMeHelp\" // default: \"help\"\n</code></pre> <p><code>--giveMeHelp</code> will now display the help message instead of <code>--help</code> for this example. This parameter will print out the help message.</p>"},{"location":"configuration/configuration/#fullparameter","title":"fullParameter","text":"<p>This option can be used to change the <code>--helpFull</code> parameter to another parameter.</p> <pre><code>validation.help.shortParameter = \"giveMeHelpFull\" // default: \"helpFull\"\n</code></pre> <p><code>--giveMeHelpFull</code> will now display the expanded help message instead of <code>--helpFull</code> for this example.</p>"},{"location":"configuration/configuration/#showhiddenparameter","title":"showHiddenParameter","text":"<p>This option can be used to change the <code>--showHidden</code> parameter to another parameter. This parameter tells the plugin to also include the hidden parameters into the help message.</p> <pre><code>validation.help.showHiddenParameter = \"showMeThoseHiddenParams\" // default: \"showHidden\"\n</code></pre> <p><code>--showMeThoseHiddenParams</code> will now make sure hidden parameters will be shown instead of <code>--showHidden</code> for this example.</p>"},{"location":"configuration/configuration/#showhidden","title":"showHidden","text":"<p>By default the parameters, that have the <code>\"hidden\": true</code> annotation in the JSON schema, will not be shown in the help message. Turning on this option will make sure the hidden parameters are also shown.</p> <pre><code>validation.help.showHidden = &lt;true|false&gt; // default: false\n</code></pre>"},{"location":"configuration/configuration/#beforetext","title":"beforeText","text":"<p>This option does not affect the help message created by the <code>paramsHelp()</code> function</p> <p>Any string provided to this option will printed before the help message.</p> <pre><code>validation.help.beforeText = \"Running pipeline version 1.0\" // default: \"\"\n</code></pre> <p>Info</p> <p>All color values (like <code>\\033[0;31m</code>, which means the color red) will be filtered out when <code>validation.monochromeLogs</code> is set to <code>true</code></p>"},{"location":"configuration/configuration/#command","title":"command","text":"<p>This option does not affect the help message created by the <code>paramsHelp()</code> function</p> <p>This option can be used to add an example command to the help message. This will be printed after the <code>beforeText</code> and before the help message.</p> <pre><code>validation.help.command = \"nextflow run main.nf --input samplesheet.csv --outdir output\" // default: \"\"\n</code></pre> <p>This example will print the following message:</p> <pre><code>Typical pipeline command:\n\n  nextflow run main.nf --input samplesheet.csv --outdir output\n</code></pre> <p>Info</p> <p>All color values (like <code>\\033[0;31m</code>, which means the color red) will be filtered out when <code>validation.monochromeLogs</code> is set to <code>true</code></p>"},{"location":"configuration/configuration/#aftertext","title":"afterText","text":"<p>This option does not affect the help message created by the <code>paramsHelp()</code> function</p> <p>Any string provided to this option will be printed after the help message.</p> <pre><code>validation.help.afterText = \"Please cite the pipeline owners when using this pipeline\" // default: \"\"\n</code></pre> <p>Info</p> <p>All color values (like <code>\\033[0;31m</code>, which means the color red) will be filtered out when <code>validation.monochromeLogs</code> is set to <code>true</code></p>"},{"location":"configuration/configuration/#summary","title":"Summary","text":"<p>The <code>validation.summary</code> config scope can be used to configure the output of the <code>paramsSummaryLog()</code> function.</p> <p>This scope contains the following options:</p>"},{"location":"configuration/configuration/#beforetext_1","title":"beforeText","text":"<p>Any string provided to this option will printed before the parameters log message.</p> <pre><code>validation.summary.beforeText = \"Running pipeline version 1.0\" // default: \"\"\n</code></pre> <p>Info</p> <p>All color values (like <code>\\033[0;31m</code>, which means the color red) will be filtered out when <code>validation.monochromeLogs</code> is set to <code>true</code></p>"},{"location":"configuration/configuration/#aftertext_1","title":"afterText","text":"<p>Any string provided to this option will be printed after the parameters log message.</p> <pre><code>validation.summary.afterText = \"Please cite the pipeline owners when using this pipeline\" // default: \"\"\n</code></pre> <p>Info</p> <p>All color values (like <code>\\033[0;31m</code>, which means the color red) will be filtered out when <code>validation.monochromeLogs</code> is set to <code>true</code></p>"},{"location":"configuration/configuration/#hideparams","title":"hideParams","text":"<p>Takes a list of parameter names to exclude from the parameters summary created by <code>paramsSummaryMap()</code> and <code>paramsSummaryLog()</code></p> <pre><code>validation.summary.hideParams = [\"param1\", \"nested.param\"] // default: []\n</code></pre>"},{"location":"contributing/setup/","title":"Getting started with plugin development","text":""},{"location":"contributing/setup/#tests","title":"Tests","text":"<p>To run the tests use the following command:</p> <pre><code>make test\n</code></pre>"},{"location":"contributing/setup/#install-and-use-in-pipelines","title":"Install and use in pipelines","text":"<p>Warning</p> <p>This method will add the development version of the plugin to your Nextflow plugins Take care when using this method and make sure that you are never using a development version to run real pipelines. You can delete all <code>nf-schema</code> versions using this command: <pre><code>rm -rf ~/.nextflow/plugins/nf-schema*\n</code></pre></p> <ul> <li>Install the current version of the plugin in your <code>.nextflow/plugins</code> folder</li> </ul> <pre><code>make install\n</code></pre> <ul> <li>Update or add the nf-schema plugin with the installed version in your test pipeline</li> </ul> nextflow.config<pre><code>plugins {\n    id 'nf-schema@x.y.z'\n}\n</code></pre>"},{"location":"contributing/setup/#change-and-preview-the-docs","title":"Change and preview the docs","text":"<p>The docs are generated using Material for MkDocs. You can install the required packages as follows:</p> <pre><code>pip install mkdocs-material pymdown-extensions pillow cairosvg\n</code></pre> <p>To change the docs, edit the files in the docs/ folder and run the following command to generate the docs:</p> <pre><code>mkdocs serve\n</code></pre> <p>To preview the docs, open the URL provided by mkdocs in your browser.</p>"},{"location":"contributing/setup/#release-and-publish-the-plugin","title":"Release and publish the plugin","text":"<ol> <li>In <code>build.gradle</code> make sure that:</li> <li><code>version</code> matches the desired release version,</li> <li><code>github.repository</code> matches the repository of the plugin,</li> <li><code>github.indexUrl</code> points to your fork of the plugins index repository.</li> <li>Create a file named <code>$HOME/.gradle/gradle.properties</code>, where <code>$HOME</code> is your home directory. Add the following properties:</li> <li><code>github_username</code>: The GitHub username granting access to the plugin repository.</li> <li><code>github_access_token</code>: The GitHub access token required to upload and commit changes to the plugin repository.</li> <li><code>github_commit_email</code>: The email address associated with your GitHub account.</li> <li>Update the changelog.</li> <li>Build and publish the plugin to your GitHub repository:    <pre><code>make release\n</code></pre></li> <li>Create a pull request against the nextflow-io/plugins repository to make the plugin publicly accessible.</li> </ol>"},{"location":"nextflow_schema/","title":"Nextflow schema for parameters","text":"<p>The functionality of the nf-schema plugin centres on a pipeline schema file. By convention, this file is stored in the workflow root directory and called <code>nextflow_schema.json</code>.</p>"},{"location":"nextflow_schema/#what-it-does","title":"What it does","text":"<p>The schema file provides a place to describe the pipeline configuration. It is based on the JSON Schema format standard.</p> <p>In brief, it includes information for each parameter about:</p> <ul> <li>Name (the <code>params.name</code>)</li> <li>Description and help texts</li> <li>Variable type (string, integer, boolean, etc)</li> <li>Validation rules (string regexes, numeric min / max, enum, etc)</li> </ul> <p>..and more. See the full specification for details.</p> <p>Warning</p> <p>Although it's based on JSON Schema - there are some differences. We use a few non-standard keys and impose one or two limitations that are not present in the standard specification.</p> <p>Tip</p> <p>It's highly recommended that you don't try to write the schema JSON file manually. Instead, use the provided tooling - see Creating schema for details.</p>"},{"location":"nextflow_schema/#how-its-used","title":"How it's used","text":"<p>The <code>nextflow_schema.json</code> file and format have been in use for a few years now and are widely used in the community. Some specific examples of usage are:</p> <ul> <li>Validation &amp; help texts within pipelines (this plugin)</li> <li>Generation of documentation pages (nf-core pipeline pages)</li> <li>Generation of pipeline launch user interfaces (nf-core launch, Nextflow Tower and more)</li> </ul>"},{"location":"nextflow_schema/#looking-to-the-future","title":"Looking to the future","text":"<p>The pipeline schema has been developed to provide additional functionality not present in core Nextflow. It's our hope that at some point this functionality will be added to core Nextflow, making schema files redundant.</p> <p>See the GitHub issue Evolution of Nextflow configuration file (<code>nextflow-io/nextflow#2723</code>) on the Nextflow repo for discussion about potential new configuration file formats, which could potentially include the kind of information that we have within schema.</p>"},{"location":"nextflow_schema/create_schema/","title":"Creating schema files","text":"<p>Warning</p> <p>It's highly recommended that you don't try to write the schema JSON file manually!</p> <p>The schema files can get large and complex and are difficult to debug. Don't be tempted to open in your code editor - instead use the provided tools!</p>"},{"location":"nextflow_schema/create_schema/#requirements","title":"Requirements","text":"<p>To work with Nextflow schema files, you need the <code>nf-core</code> command-line tools package. You can find full installation instructions in the nf-core documentation, but in brief, you install as with any other Python package:</p> <pre><code>pip install nf-core\n# -- OR -- #\nconda install nf-core # (1)!\n</code></pre> <ol> <li> Note: Needs bioconda channels to be configured!     See the Bioconda usage docs.</li> </ol> <p>Info</p> <p>Although these tools are currently within the nf-core tooling ecosystem, they should work with any Nextflow pipeline: you don't have to be using the nf-core template for this.</p> <p>Note</p> <p>We aim to extract this functionality into stand-alone tools at a future date, as we have done with the pipeline validation code in this plugin.</p>"},{"location":"nextflow_schema/create_schema/#build-a-pipeline-schema","title":"Build a pipeline schema","text":"<p>Once you have nf-core/tools installed and have written your pipeline configuration, go to the pipeline root and run the following:</p> <pre><code>nf-core schema build\n</code></pre> <p>Warning</p> <p>The current version of <code>nf-core</code> tools (v2.13.1) does not support the new schema draft used in <code>nf-schema</code>. Running this command after building the schema will convert the schema to the right draft:</p> <p><pre><code>sed -i -e 's/http:\\/\\/json-schema.org\\/draft-07\\/schema/https:\\/\\/json-schema.org\\/draft\\/2020-12\\/schema/g' -e 's/definitions/$defs/g' nextflow_schema.json\n</code></pre> A new version of the nf-core schema builder will be available soon. Keep an eye out!</p> <p>The tool will run the <code>nextflow config</code> command to extract your pipeline's configuration and compare the output to your <code>nextflow_schema.json</code> file (if it exists). It will prompt you to update the schema file with any changes, then it will ask if you wish to edit the schema using the web interface.</p> <p>This web interface is where you should add detail to your schema, customising the various fields for each parameter.</p> <p>Tip</p> <p>You can run the <code>nf-core schema build</code> command again and again, as many times as you like. It's designed both for initial creation but also future updates of the schema file.</p> <p>It's a good idea to \"save little and often\" by clicking <code>Finished</code> and saving your work locally, then running the command again to continue.</p>"},{"location":"nextflow_schema/create_schema/#build-a-sample-sheet-schema","title":"Build a sample sheet schema","text":"<p>Danger</p> <p>There is currently no tooling to help you write sample sheet schema </p> <p>You can find an example in Example sample sheet schema</p> <p>Watch this space..</p>"},{"location":"nextflow_schema/nextflow_schema_examples/","title":"Example Nextflow schema","text":"<p>You can see an example JSON Schema for a Nextflow pipeline <code>nextflow_schema.json</code> file below.</p> <p>This file was generated from the nf-core pipeline template, using <code>nf-core create</code>. It is used as a test fixture in the nf-schema package here.</p> <p>Note</p> <p>More examples can be found in the plugin <code>testResources</code> directory.</p> <pre><code>\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/","title":"Nextflow schema specification","text":"<p>The Nextflow schema file contains information about pipeline configuration parameters. The file is typically saved in the workflow root directory and called <code>nextflow_schema.json</code>.</p> <p>The Nextflow schema syntax is based on the JSON schema standard, with some key differences. You can find more information about JSON Schema here:</p> <ul> <li>Official docs: https://json-schema.org</li> <li>Excellent \"Understanding JSON Schema\" docs: https://json-schema.org/understanding-json-schema</li> </ul> <p>Warning</p> <p>This file is a reference specification, not documentation about how to write a schema manually.</p> <p>Please see Creating schema files for instructions on how to create these files (and don't be tempted to do it manually in a code editor!)</p> <p>Note</p> <p>The nf-schema plugin, as well as several other interfaces using Nextflow schema, uses a stock JSON schema library for parameter validation. As such, any valid JSON schema should work for validation.</p> <p>However, please note that graphical UIs (docs, launch interfaces) are largely hand-written and may not expect JSON schema usage that is not described here. As such, it's safest to stick to the specification described here and not the core JSON schema spec.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#definitions","title":"Definitions","text":"<p>A slightly strange use of a JSON schema standard that we use for Nextflow schema is <code>$defs</code>.</p> <p>JSON schema can group variables together in an <code>object</code>, but then the validation expects this structure to exist in the data that it is validating. In reality, we have a very long \"flat\" list of parameters, all at the top level of <code>params.foo</code>.</p> <p>In order to give some structure to log outputs, documentation and so on, we group parameters into <code>$defs</code>. Each <code>def</code> is an object with a title, description and so on. However, as they are under <code>$defs</code> scope they are effectively ignored by the validation and so their nested nature is not a problem. We then bring the contents of each definition object back to the \"flat\" top level for validation using a series of <code>allOf</code> statements at the end of the schema, which reference the specific definition keys.</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"type\": \"object\",\n  // Definition groups\n  \"$defs\": { // (1)!\n    \"my_group_of_params\": { // (2)!\n      \"title\": \"A virtual grouping used for docs and pretty-printing\",\n      \"type\": \"object\",\n      \"required\": [\"foo\", \"bar\"], // (3)!\n      \"properties\": { // (4)!\n        \"foo\": { // (5)!\n          \"type\": \"string\"\n        },\n        \"bar\": {\n          \"type\": \"string\"\n        }\n      }\n    }\n  },\n  // Contents of each definition group brought into main schema for validation\n  \"allOf\": [\n    { \"$ref\": \"#/$defs/my_group_of_params\" } // (6)!\n  ]\n}\n</code></pre> <ol> <li>An arbitrary number of definition groups can go in here - these are ignored by main schema validation.</li> <li>This ID is used later in the <code>allOf</code> block to reference the definition.</li> <li>Note that any required properties need to be listed within this object scope.</li> <li>Actual parameter specifications go in here.</li> <li>Shortened here for the example, see below for full parameter specification.</li> <li>A <code>$ref</code> line like this needs to be added for every definition group</li> </ol> <p>Parameters can be described outside of the <code>$defs</code> scope, in the regular JSON Schema top-level <code>properties</code> scope. However, they will be displayed as ungrouped in tools working off the schema.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#nested-parameters","title":"Nested parameters","text":"<p>New feature in v2.1.0</p> <p>Nextflow config allows parameters to be nested as objects, for example:</p> <pre><code>params {\n    foo {\n        bar = \"baz\"\n    }\n}\n</code></pre> <p>or on the CLI:</p> <pre><code>nextflow run &lt;pipeline&gt; --foo.bar \"baz\"\n</code></pre> <p>Nested parameters can be specified in the schema by adding a <code>properties</code> keyword to the root parameters:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"thisIsNested\": {\n      // Annotation for the --thisIsNested parameter\n      \"type\": \"object\", // Parameters that contain subparameters need to have the \"object\" type\n      \"properties\": {\n        // Add other parameters in here\n        \"deep\": {\n          // Annotation for the --thisIsNested.deep parameter\n          \"type\": \"string\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>There is no limit to how deeply nested parameters can be. Mind however that deeply nested parameters are not that user friendly and will create some very ugly help messages. It's advised to not go deeper than two levels of nesting.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#required-parameters","title":"Required parameters","text":"<p>Any parameters that must be specified should be set as <code>required</code> in the schema.</p> <p>Tip</p> <p>Make sure you do set <code>null</code> as a default value for the parameter, otherwise it will have a value even if not supplied by the pipeline user and the required property will have no effect.</p> <p>This is not done with a property key like other things described below, but rather by naming the parameter in the <code>required</code> array in the definition object / top-level object.</p> <p>For more information, see the JSON schema documentation.</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": { \"type\": \"string\" },\n    \"email\": { \"type\": \"string\" },\n    \"address\": { \"type\": \"string\" },\n    \"telephone\": { \"type\": \"string\" }\n  },\n  \"required\": [\"name\", \"email\"]\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#parameter-name","title":"Parameter name","text":"<p>The <code>properties</code> object key must correspond to the parameter variable name in the Nextflow config.</p> <p>For example, for <code>params.foo</code>, the schema should look like this:</p> <pre><code>// ..\n\"type\": \"object\",\n\"properties\": {\n    \"foo\": {\n        \"type\": \"string\",\n        // ..\n    }\n}\n// ..\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#keys-for-all-parameters","title":"Keys for all parameters","text":""},{"location":"nextflow_schema/nextflow_schema_specification/#type","title":"<code>type</code>","text":"<p>Variable type, taken from the JSON schema keyword vocabulary:</p> <ul> <li><code>string</code></li> <li><code>number</code> (float)</li> <li><code>integer</code></li> <li><code>boolean</code> (true / false)</li> <li><code>object</code> (currently only supported for file validation, see Nested paramters)</li> <li><code>array</code> (currently only supported for file validation, see Nested paramters)</li> </ul> <p>Validation checks that the supplied parameter matches the expected type, and will fail with an error if not.</p> <p>This JSON schema type is not supported:</p> <ul> <li><code>null</code></li> </ul>"},{"location":"nextflow_schema/nextflow_schema_specification/#default","title":"<code>default</code>","text":"<p>Default value for the parameter.</p> <p>Should match the <code>type</code> and validation patterns set for the parameter in other fields.</p> <p>Tip</p> <p>If no default should be set, completely omit this key from the schema. Do not set it as an empty string, or <code>null</code>.</p> <p>However, parameters with no defaults should be set to <code>null</code> within your Nextflow config file.</p> <p>Note</p> <p>When creating a schema using <code>nf-core schema build</code>, this field will be automatically created based on the default value defined in the pipeline config files.</p> <p>Generally speaking, the two should always be kept in sync to avoid unexpected problems and usage errors. In some rare cases, this may not be possible (for example, a dynamic groovy expression cannot be encoded in JSON), in which case try to specify as \"sensible\" a default within the schema as possible.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#description","title":"<code>description</code>","text":"<p>A short description of what the parameter does, written in markdown. Printed in docs and terminal help text. Should be maximum one short sentence.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#help_text","title":"<code>help_text</code>","text":"<p>Non-standard key</p> <p>A longer text with usage help for the parameter, written in markdown. Can include newlines with multiple paragraphs and more complex markdown structures.</p> <p>Typically hidden by default in documentation and interfaces, unless explicitly clicked / requested.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#errormessage","title":"<code>errorMessage</code>","text":"<p>Non-standard key</p> <p>If validation fails, an error message is printed to the terminal, so that the end user knows what to fix. However, these messages are not always very clear - especially to newcomers.</p> <p>To improve this experience, pipeline developers can set a custom <code>errorMessage</code> for a given parameter in a the schema. If validation fails, this <code>errorMessage</code> is printed after the original error message to guide the pipeline users to an easier solution.</p> <p>For example, instead of printing:</p> <pre><code>* --input (samples.yml): \"samples.yml\" does not match regular expression [^\\S+\\.csv$]\n</code></pre> <p>We can set</p> <pre><code>\"input\": {\n  \"type\": \"string\",\n  \"pattern\": \"^\\S+\\.csv$\",\n  \"errorMessage\": \"File name must end in '.csv' cannot contain spaces\"\n}\n</code></pre> <p>and get:</p> <pre><code>* --input (samples.yml): \"samples.yml\" does not match regular expression [^\\S+\\.csv$] (File name must end in '.csv' cannot contain spaces)\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#deprecated","title":"<code>deprecated</code>","text":"<p>Extended key</p> <p>A boolean JSON flag that instructs anything using the schema that this parameter/field is deprecated and should not be used. This can be useful to generate messages telling the user that a parameter has changed between versions.</p> <p>JSON schema states that this is an informative key only, but in <code>nf-schema</code> this will cause a validation error if the parameter/field is used.</p> <p>Tip</p> <p>Using the <code>errorMessage</code> keyword can be useful to provide more information about the deprecation and what to use instead.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#enum","title":"<code>enum</code>","text":"<p>An array of enumerated values: the parameter must match one of these values exactly to pass validation.</p> <ul> <li>See the JSON schema docs   for details.</li> <li>Available for strings, numbers and integers.</li> </ul> <pre><code>{\n  \"enum\": [\"red\", \"amber\", \"green\"]\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#fa_icon","title":"<code>fa_icon</code>","text":"<p>Non-standard key</p> <p>A text identifier corresponding to an icon from Font Awesome. Used for easier visual navigation of documentation and pipeline interfaces.</p> <p>Should be the font-awesome class names, for example:</p> <pre><code>\"fa_icon\": \"fas fa-file-csv\"\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#hidden","title":"<code>hidden</code>","text":"<p>Non-standard key</p> <p>A boolean JSON flag that instructs anything using the schema that this is an unimportant parameter.</p> <p>Typically used to keep the pipeline docs / UIs uncluttered with common parameters which are not used by the majority of users. For example, <code>--plaintext_email</code> and <code>--monochrome_logs</code>.</p> <pre><code>\"hidden\": true\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#string-specific-keys","title":"String-specific keys","text":""},{"location":"nextflow_schema/nextflow_schema_specification/#pattern","title":"<code>pattern</code>","text":"<p>Regular expression which the string must match in order to pass validation.</p> <ul> <li>See the JSON schema docs   for details.</li> <li>Use https://regex101.com/ for help with writing regular expressions.</li> </ul> <p>For example, this pattern only validates if the supplied string ends in <code>.fastq</code>, <code>.fq</code>, <code>.fastq.gz</code> or <code>.fq.gz</code>:</p> <pre><code>{\n  \"type\": \"string\",\n  \"pattern\": \".*.f(ast)?q(.gz)?$\"\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#minlength-maxlength","title":"<code>minLength</code>, <code>maxLength</code>","text":"<p>Specify a minimum / maximum string length with <code>minLength</code> and <code>maxLength</code>.</p> <ul> <li>See the JSON schema docs   for details.</li> </ul> <pre><code>{\n  \"type\": \"string\",\n  \"minLength\": 2,\n  \"maxLength\": 3\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#format","title":"<code>format</code>","text":"<p>Formats can be used to give additional validation checks against <code>string</code> values for certain properties.</p> <p>Non-standard key (values)</p> <p>The <code>format</code> key is a standard JSON schema key, however we primarily use it for validating file / directory path operations with non-standard schema values.</p> <p>Example usage is as follows:</p> <pre><code>{\n  \"type\": \"string\",\n  \"format\": \"file-path\"\n}\n</code></pre> <p>The available <code>format</code> types are below:</p> <code>file-path</code> States that the provided value is a file. Does not check its existence, but it does check if the path is not a directory. <code>directory-path</code> States that the provided value is a directory. Does not check its existence, but if it exists, it does check that the path is not a file. <code>path</code> States that the provided value is a path (file or directory). Does not check its existence. <code>file-path-pattern</code> States that the provided value is a glob pattern that will be used to fetch files. Checks that the pattern is valid and that at least one file is found."},{"location":"nextflow_schema/nextflow_schema_specification/#exists","title":"<code>exists</code>","text":"<p>When a format is specified for a value, you can provide the key <code>exists</code> set to true in order to validate that the provided path exists. Set this to <code>false</code> to validate that the path does not exist.</p> <p>Example usage is as follows:</p> <pre><code>{\n  \"type\": \"string\",\n  \"format\": \"file-path\",\n  \"exists\": true\n}\n</code></pre> <p>Note</p> <p>If the parameter is an S3, Azure or Google Cloud URI path, this validation is ignored.</p> <p>Warning</p> <p>Make sure to only use the <code>exists</code> keyword in combination with any file path format. Using <code>exists</code> on a normal string will assume that it's a file and will probably fail unexpectedly.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#mimetype","title":"<code>mimetype</code>","text":"<p>MIME type for a file path. Setting this value informs downstream tools about what kind of file is expected.</p> <p>Should only be set when <code>format</code> is <code>file-path</code>.</p> <ul> <li>See a list of common MIME types</li> </ul> <pre><code>{\n  \"type\": \"string\",\n  \"format\": \"file-path\",\n  \"mimetype\": \"text/csv\"\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#schema","title":"<code>schema</code>","text":"<p>Path to a JSON schema file used to validate the supplied file.</p> <p>Should only be set when <code>format</code> is <code>file-path</code>.</p> <p>Tip</p> <p>Setting this field is key to working with sample sheet validation and channel generation, as described in the next section of the nf-schema docs.</p> <p>These schema files are typically stored in the pipeline <code>assets</code> directory, but can be anywhere.</p> <pre><code>{\n  \"type\": \"string\",\n  \"format\": \"file-path\",\n  \"schema\": \"assets/foo_schema.json\"\n}\n</code></pre> <p>Note</p> <p>If the parameter is set to <code>null</code>, <code>false</code> or an empty string, this validation is ignored. The file won't be validated.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#numeric-specific-keys","title":"Numeric-specific keys","text":""},{"location":"nextflow_schema/nextflow_schema_specification/#minimum-maximum","title":"<code>minimum</code>, <code>maximum</code>","text":"<p>Specify a minimum / maximum value for an integer or float number length with <code>minimum</code> and <code>maximum</code>.</p> <ul> <li>See the JSON schema docs   for details.</li> </ul> <p>If x is the value being validated, the following must hold true:</p> <ul> <li><code>x</code> \u2265 <code>minimum</code></li> <li><code>x</code> \u2264 <code>maximum</code></li> </ul> <pre><code>{\n  \"type\": \"number\",\n  \"minimum\": 0,\n  \"maximum\": 100\n}\n</code></pre> <p>Note</p> <p>The JSON schema doc also mention <code>exclusiveMinimum</code>, <code>exclusiveMaximum</code> and <code>multipleOf</code> keys. Because nf-schema uses stock JSON schema validation libraries, these should work for validating keys. However, they are not officially supported within the Nextflow schema ecosystem and so some interfaces may not recognise them.</p>"},{"location":"nextflow_schema/nextflow_schema_specification/#array-specific-keys","title":"Array-specific keys","text":""},{"location":"nextflow_schema/nextflow_schema_specification/#uniqueitems","title":"<code>uniqueItems</code>","text":"<p>All items in the array should be unique.</p> <ul> <li>See the JSON schema docs   for details.</li> </ul> <pre><code>{\n  \"type\": \"array\",\n  \"uniqueItems\": true\n}\n</code></pre>"},{"location":"nextflow_schema/nextflow_schema_specification/#uniqueentries","title":"<code>uniqueEntries</code>","text":"<p>Non-standard key</p> <p>The combination of all values in the given keys should be unique. For this key to work you need to make sure the array items are of type <code>object</code> and contains the keys in the <code>uniqueEntries</code> list.</p> <pre><code>{\n  \"type\": \"array\",\n  \"uniqueEntries\": [\"foo\", \"bar\"],\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"foo\": { \"type\": \"string\" },\n      \"bar\": { \"type\": \"string\" }\n    }\n  }\n}\n</code></pre> <p>This schema tells <code>nf-schema</code> that the combination of <code>foo</code> and <code>bar</code> should be unique across all objects in the array.</p>"},{"location":"nextflow_schema/sample_sheet_schema_examples/","title":"Example sample sheet schema","text":""},{"location":"nextflow_schema/sample_sheet_schema_examples/#nf-corernaseq-example","title":"nf-core/rnaseq example","text":"<p>The nf-core/rnaseq pipeline was one of the first to have a sample sheet schema. You can see this, used for validating sample sheets with <code>--input</code> here: <code>assets/schema_input.json</code>.</p> <p>Tip</p> <p>Note the approach used for validating filenames in the <code>fastq_2</code> column. The column is optional, so if a <code>pattern</code> was supplied by itself then validation would fail when no string is supplied.</p> <p>Instead, we say that the string must either match that pattern or it must have a <code>maxLength</code> of <code>0</code> (an empty string).</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/nf-core/rnaseq/master/assets/schema_input.json\",\n  \"title\": \"nf-core/rnaseq pipeline - params.input schema\",\n  \"description\": \"Schema for the file provided with params.input\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"sample\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+$\",\n        \"errorMessage\": \"Sample name must be provided and cannot contain spaces\",\n        \"meta\": [\"my_sample\"]\n      },\n      \"fastq_1\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\",\n        \"format\": \"file-path\",\n        \"errorMessage\": \"FastQ file for reads 1 must be provided, cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\"\n      },\n      \"fastq_2\": {\n        \"errorMessage\": \"FastQ file for reads 2 cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\",\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\",\n        \"format\": \"file-path\"\n      },\n      \"strandedness\": {\n        \"type\": \"string\",\n        \"errorMessage\": \"Strandedness must be provided and be one of 'forward', 'reverse' or 'unstranded'\",\n        \"enum\": [\"forward\", \"reverse\", \"unstranded\"],\n        \"meta\": [\"my_strandedness\"]\n      }\n    },\n    \"required\": [\"sample\", \"fastq_1\", \"strandedness\"]\n  }\n}\n</code></pre>"},{"location":"nextflow_schema/sample_sheet_schema_examples/#nf-schema-test-case","title":"nf-schema test case","text":"<p>You can see a very feature-complete example JSON Schema for a sample sheet schema file below.</p> <p>It is used as a test fixture in the nf-schema package here.</p> <p>Note</p> <p>More examples can be found in the plugin <code>testResources</code> directory.</p> <pre><code>\n</code></pre>"},{"location":"nextflow_schema/sample_sheet_schema_specification/","title":"Sample sheet schema specification","text":"<p>Sample sheet schema files are used by the nf-schema plugin for validation of sample sheet contents and type conversion / channel generation.</p> <p>The Nextflow schema syntax is based on the JSON schema standard. You can find more information about JSON Schema here:</p> <ul> <li>Official docs: https://json-schema.org</li> <li>Excellent \"Understanding JSON Schema\" docs: https://json-schema.org/understanding-json-schema</li> </ul>"},{"location":"nextflow_schema/sample_sheet_schema_specification/#schema-structure","title":"Schema structure","text":"<p>Validation by the plugin works by parsing the supplied file contents into a groovy object, then passing this to the JSON schema validation library. As such, the structure of the schema must match the structure of the parsed file.</p> <p>Typically, samplesheets are CSV files, with fields represented as columns and samples as rows. TSV, JSON and YAML samplesheets are also supported by this plugin</p> <p>In this case, the parsed object will be an <code>array</code> (see JSON schema docs). The array type is associated with an <code>items</code> key which in our case contains a single <code>object</code>. The object has <code>properties</code>, where the keys must match the headers of the CSV file.</p> <p>So, for CSV samplesheets, the top-level schema should look something like this:</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"field_1\": { \"type\": \"string\" },\n      \"field_2\": { \"type\": \"string\" }\n    }\n  }\n}\n</code></pre> <p>If your sample sheet has a different format (for example, a nested YAML file), you will need to build your schema to match the parsed structure.</p>"},{"location":"nextflow_schema/sample_sheet_schema_specification/#properties","title":"Properties","text":"<p>Every array object will contain keys for each field. Each field should be described as an element in the object <code>properties</code> section.</p> <p>The keys of each property must match the header text used in the sample sheet.</p> <p>Fields that are present in the sample sheet, but not in the schema will be ignored and produce a warning.</p> <p>Tip</p> <p>The order of columns in the sample sheet is not relevant, as long as the header text matches.</p> <p>Warning</p> <p>The order of properties in the schema is important. This order defines the order of output channel properties when using the <code>samplesheetToList()</code> function.</p>"},{"location":"nextflow_schema/sample_sheet_schema_specification/#common-keys","title":"Common keys","text":"<p>The majority of schema keys for sample sheet schema validation are identical to the Nextflow schema. For example: <code>type</code>, <code>pattern</code>, <code>format</code>, <code>errorMessage</code>, <code>exists</code> and so on.</p> <p>Please refer to the Nextflow schema specification docs for details.</p>"},{"location":"nextflow_schema/sample_sheet_schema_specification/#sample-sheet-keys","title":"Sample sheet keys","text":"<p>Below are the properties that are specific to sample sheet schema. These exist in addition to those described in the Nextflow schema specification.</p>"},{"location":"nextflow_schema/sample_sheet_schema_specification/#meta","title":"<code>meta</code>","text":"<p>Type: <code>List</code> or <code>String</code></p> <p>The current field will be considered a meta value when this parameter is present. This parameter should contain a list of the meta fields or a string stating a single meta field to assign this value to. The default is no meta for each field.</p> <p>For example:</p> <pre><code>{\n  \"meta\": \"id\"\n}\n</code></pre> <p>will convert the <code>field</code> value to a meta value, resulting in the channel <code>[[id:value]...]</code> See here for an example in the sample sheet.</p>"},{"location":"parameters/help_text/","title":"Parameter help","text":""},{"location":"parameters/help_text/#configure-help-message","title":"Configure help message","text":"<p>Add the following configuration to your configuration files to enable the creation of help messages:</p> nextflow.config<pre><code>validation {\n    help {\n        enabled = true\n    }\n}\n</code></pre> <p>That's it! Every time the pipeline user passes the <code>--help</code> and <code>--helpFull</code> parameters to the pipeline, the help message will be created!</p> <p>The help message can be customized with a series of different options. See help configuration docs for a list of all options.</p>"},{"location":"parameters/help_text/#help-message","title":"Help message","text":"<p>Following example shows a snippet of a JSON schema which can be used to perfect visualize the differences between the different help messages. This schema contains one group of parameters called <code>Input parameters</code> that contains two parameters: <code>--input</code> and <code>--outdir</code>. There are also two ungrouped parameters in this schema: <code>--reference</code> and <code>--type</code>. <code>--reference</code> is a nested parameter that contains the <code>.fasta</code>, <code>.fai</code> and <code>.aligners</code> subparameters. <code>.aligners</code> also contains two subparameters: <code>.bwa</code> and <code>.bowtie</code>.</p> <p>There are three different help messages:</p> <ol> <li>Using <code>--help</code> will only show the top level parameters (<code>--input</code>, <code>--outdir</code>, <code>--reference</code> and <code>--type</code> in the example). The type, description, possible options and defaults of these parameters will also be added to the message if they are present in the JSON schema.</li> <li>Using <code>--helpFull</code> will print all parameters (no matter how deeply nested they are) (<code>--input</code>, <code>--outdir</code>, <code>--reference.fasta</code>, <code>--reference.fai</code>, <code>--reference.aligners.bwa</code>, <code>--reference.aligners.bowtie</code> and <code>--type</code> in the example)</li> <li><code>--help</code> can also be used with a parameter given to it. This will print out a detailed help message of the parameter. This will also show the subparameters present for the parameter.</li> </ol> JSON schema<code>--help</code><code>--helpFull</code><code>--help input</code><code>--help reference.aligners</code> <pre><code>...\n\"$defs\": { // A section to define several definition in the JSON schema\n    \"Input parameters\": { // A group called \"Input parameters\"\n        \"properties\": { // All properties (=parameters) in this group\n            \"input\": {\n                \"type\": \"string\",\n                \"description\": \"The input samplesheet\",\n                \"format\": \"file-path\",\n                \"pattern\": \"^.$\\.csv$\",\n                \"help_text\": \"This file needs to contain all input samples\",\n                \"exists\": true\n            },\n            \"outdir\": {\n                \"type\": \"string\",\n                \"description\": \"The output directory\",\n                \"format\": \"directory-path\",\n                \"default\": \"results\"\n            }\n        }\n    }\n},\n\"properties\": { // Ungrouped parameters go here\n    \"reference\": {\n        \"type\": \"object\", // A parameter that contains nested parameters is always an \"object\"\n        \"description\": \"A group of parameters to configure the reference sets\",\n        \"properties\": { // All parameters nested in the --reference parameter\n            \"fasta\": {\n                \"type\": \"string\",\n                \"description\": \"The FASTA file\"\n            },\n            \"fai\": {\n                \"type\": \"string\",\n                \"description\": \"The FAI file\"\n            },\n            \"aligners\": {\n                \"type\": \"object\",\n                \"description\": \"A group of parameters specifying the aligner indices\",\n                \"properties\": { // All parameters nested in the --reference.aligners parameter\n                    \"bwa\": {\n                        \"type\": \"string\",\n                        \"description\": \"The BWA index\"\n                    },\n                    \"bowtie\": {\n                        \"type\": \"string\",\n                        \"description\": \"The BOWTIE index\"\n                    }\n                }\n            }\n        }\n    },\n    \"type\": {\n        \"type\": \"string\",\n        \"description\": \"The analysis type\",\n        \"enum\": [\"WES\",\"WGS\"]\n    }\n}\n...\n</code></pre> <pre><code>--reference  [object]          A group of parameters to configure the reference sets\n--type       [string]          The analysis type (accepted: WES, WGS)\n--help       [boolean, string] Show the help message for all top level parameters. When a parameter is given to `--help`, the full help message of that parameter will be printed.\n--helpFull   [boolean]         Show the help message for all non-hidden parameters.\n--showHidden [boolean]         Show all hidden parameters in the help message. This needs to be used in combination with `--help` or `--helpFull`.\n\nInput parameters\n    --input  [string] The input samplesheet\n    --outdir [string] The output directory [default: results]\n</code></pre> <pre><code>--reference.fasta           [string]          The FASTA file\n--reference.fai             [string]          The FAI file\n--reference.aligners.bwa    [string]          The BWA index\n--reference.aligners.bowtie [string]          The BOWTIE index\n--type                      [string]          The analysis type (accepted: WES, WGS)\n--help                      [boolean, string] Show the help message for all top level parameters. When a parameter is given to `--help`, the full help message of that parameter will be printed.\n--helpFull                  [boolean]         Show the help message for all non-hidden parameters.\n--showHidden                [boolean]         Show all hidden parameters in the help message. This needs to be used in combination with `--help` or `--helpFull`.\n\nInput parameters\n    --input                 [string] The input samplesheet\n    --outdir                [string] The output directory [default: results]\n</code></pre> <pre><code>--input\n    type       : string\n    description: The input samplesheet\n    format     : file-path\n    pattern    : ^.$\\.csv$\n    help_text  : This file needs to contain all input samples\n    exists     : true\n</code></pre> <pre><code>--reference.aligners\n    type       : object\n    description: A group of parameters specifying the aligner indices\n    options    :\n        --reference.aligners.bwa    [string] The BWA index\n        --reference.aligners.bowtie [string] The BOWTIE index\n</code></pre> <p>The help message will always show the ungrouped parameters first. <code>--help</code>, <code>--helpFull</code> and <code>--showHidden</code> will always be automatically added to the help message. These defaults can be overwritten by adding them as ungrouped parameters to the JSON schema.</p> <p>After the ungrouped parameters, the grouped parameters will be printed.</p>"},{"location":"parameters/help_text/#hidden-parameters","title":"Hidden parameters","text":"<p>Params that are set as <code>hidden</code> in the JSON Schema are not shown in the help message. To show these parameters, pass the <code>--showHidden</code> parameter to the nextflow command.</p>"},{"location":"parameters/help_text/#coloured-logs","title":"Coloured logs","text":"<p>By default, the help output is coloured using ANSI escape codes.</p> <p>If you prefer, you can disable these by setting the <code>validation.monochromeLogs</code> configuration option to <code>true</code></p> Default (coloured)Monochrome logs <p></p> <p></p>"},{"location":"parameters/help_text/#paramshelp","title":"<code>paramsHelp()</code>","text":"<p>Deprecated</p> <p>This function has been deprecated in v2.1.0. Use the help configuration instead</p> <p>This function returns a help message with the command to run a pipeline and the available parameters. Pass it to <code>log.info</code> to print in the terminal.</p> <p>It accepts three arguments:</p> <ol> <li>An example command, typically used to run the pipeline, to be included in the help string</li> <li>An option to set the file name of a Nextflow Schema file: <code>parameters_schema: &lt;schema.json&gt;</code> (Default: <code>nextflow_schema.json</code>)</li> <li>An option to hide the deprecation warning: <code>hideWarning: &lt;true/false&gt;</code> (Default: <code>false</code>)</li> </ol> <p>Note</p> <p><code>paramsHelp()</code> doesn't stop pipeline execution after running. You must add this into your pipeline code if it's the desired functionality.</p> <p>Typical usage:</p> main.nfnextflow.confignextflow_schema.json <pre><code>include { paramsHelp } from 'plugin/nf-schema'\n\nif (params.help) {\n    log.info paramsHelp(\"nextflow run my_pipeline --input input_file.csv\")\n    exit 0\n}\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  outdir = \"results\"\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$id\": \"https://raw.githubusercontent.com/nf-core/testpipeline/master/nextflow_schema.json\",\n    \"title\": \"nf-core/testpipeline pipeline parameters\",\n    \"description\": \"this is a test\",\n    \"type\": \"object\",\n    \"$defs\": {\n        \"input_output_options\": {\n            \"title\": \"Input/output options\",\n            \"type\": \"object\",\n            \"fa_icon\": \"fas fa-terminal\",\n            \"description\": \"Define where the pipeline should find input data and save output data.\",\n            \"required\": [\"input\", \"outdir\"],\n            \"properties\": {\n                \"input\": {\n                    \"type\": \"string\",\n                    \"format\": \"file-path\",\n                    \"mimetype\": \"text/csv\",\n                    \"schema\": \"assets/schema_input.json\",\n                    \"pattern\": \"^\\\\S+\\\\.(csv|tsv|yaml|json)$\",\n                    \"description\": \"Path to comma-separated file containing information about the samples in the experiment.\",\n                    \"help_text\": \"You will need to create a design file with information about the samples in your experiment before running the pipeline. Use this parameter to specify its location. It has to be a comma-separated file with 3 columns, and a header row. See [usage docs](https://nf-co.re/testpipeline/usage#samplesheet-input).\",\n                    \"fa_icon\": \"fas fa-file-csv\"\n                },\n                \"outdir\": {\n                    \"type\": \"string\",\n                    \"format\": \"directory-path\",\n                    \"description\": \"The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.\",\n                    \"fa_icon\": \"fas fa-folder-open\"\n                }\n            }\n        }\n    },\n    \"allOf\": [\n        {\n            \"$ref\": \"#/$defs/input_output_options\"\n        }\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [infallible_turing] DSL2 - revision: 8bf4c8d053\n\nTypical pipeline command:\n\n  nextflow run my_pipeline --input input_file.csv\n\nInput/output options\n  --input  [string]  Path to comma-separated file containing information about the samples in the experiment.\n  --outdir [string]  The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.\n\n------------------------------------------------------\n</code></pre> <p>Warning</p> <p>We shouldn't be using <code>exit</code> as it kills the Nextflow head job in a way that is difficult to handle by systems that may be running it externally, but at the time of writing there is no good alternative. See <code>nextflow-io/nextflow#3984</code>.</p>"},{"location":"parameters/summary_log/","title":"Summary log","text":""},{"location":"parameters/summary_log/#paramssummarylog","title":"<code>paramsSummaryLog()</code>","text":"<p>This function returns a string that can be logged to the terminal, summarizing the parameters provided to the pipeline.</p> <p>Note</p> <p>The summary prioritizes displaying only the parameters that are different than the default schema values. Parameters which don't have a default in the JSON Schema and which have a value of <code>null</code>, <code>\"\"</code>, <code>false</code> or <code>'false'</code> won't be returned in the map. This is to streamline the extensive parameter lists often associated with pipelines, and highlight the customized elements. This feature is essential for users to verify their configurations, like checking for typos or confirming proper resolution, without wading through an array of default settings.</p> <p>The function takes two arguments:</p> <ul> <li>The <code>WorkflowMetadata</code> object, <code>workflow</code> (required)</li> <li>File name of a schema file (optional, default: <code>nextflow_schema.json</code>).</li> </ul> <p>Typical usage:</p> main.nfnextflow.confignextflow_schema.json <pre><code>include { paramsSummaryLog } from 'plugin/nf-schema'\n\nlog.info paramsSummaryLog(workflow)\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  outdir = \"results\"\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$id\": \"https://raw.githubusercontent.com/nf-core/testpipeline/master/nextflow_schema.json\",\n    \"title\": \"nf-core/testpipeline pipeline parameters\",\n    \"description\": \"this is a test\",\n    \"type\": \"object\",\n    \"$defs\": {\n        \"input_output_options\": {\n            \"title\": \"Input/output options\",\n            \"type\": \"object\",\n            \"fa_icon\": \"fas fa-terminal\",\n            \"description\": \"Define where the pipeline should find input data and save output data.\",\n            \"required\": [\"input\", \"outdir\"],\n            \"properties\": {\n                \"input\": {\n                    \"type\": \"string\",\n                    \"format\": \"file-path\",\n                    \"mimetype\": \"text/csv\",\n                    \"schema\": \"assets/schema_input.json\",\n                    \"pattern\": \"^\\\\S+\\\\.(csv|tsv|yaml|json)$\",\n                    \"description\": \"Path to comma-separated file containing information about the samples in the experiment.\",\n                    \"help_text\": \"You will need to create a design file with information about the samples in your experiment before running the pipeline. Use this parameter to specify its location. It has to be a comma-separated file with 3 columns, and a header row. See [usage docs](https://nf-co.re/testpipeline/usage#samplesheet-input).\",\n                    \"fa_icon\": \"fas fa-file-csv\"\n                },\n                \"outdir\": {\n                    \"type\": \"string\",\n                    \"format\": \"directory-path\",\n                    \"description\": \"The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.\",\n                    \"fa_icon\": \"fas fa-folder-open\"\n                }\n            }\n        }\n    },\n    \"allOf\": [\n        {\n            \"$ref\": \"#/$defs/input_output_options\"\n        }\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [sleepy_goldberg] DSL2 - revision: 7a280216f3\n\nCore Nextflow options\n  runName    : sleepy_goldberg\n  launchDir  : /Users/demo/GitHub/nextflow-io/nf-schema/examples/paramsSummaryLog\n  workDir    : /Users/demo/GitHub/nextflow-io/nf-schema/examples/paramsSummaryLog/work\n  projectDir : /Users/demo/GitHub/nextflow-io/nf-schema/examples/paramsSummaryLog/pipeline\n  userName   : demo\n  profile    : standard\n  configFiles:\n\nInput/output options\n  input      : samplesheet.csv\n  outdir     : results\n\n!! Only displaying parameters that differ from the pipeline defaults !!\n------------------------------------------------------\n</code></pre>"},{"location":"parameters/summary_log/#coloured-logs","title":"Coloured logs","text":"<p>By default, the summary output is coloured using ANSI escape codes.</p> <p>If you prefer, you can disable these by using the argument monochrome_logs, e.g. <code>paramsHelp(monochrome_logs: true)</code>. Alternatively this can be set at a global level via parameter <code>--monochrome_logs</code> or adding <code>params.monochrome_logs = true</code> to a configuration file. Not <code>--monochromeLogs</code> or <code>params.monochromeLogs</code> is also supported.</p> Default (coloured)Monochrome logs <p></p> <p></p>"},{"location":"parameters/summary_log/#paramssummarymap","title":"<code>paramsSummaryMap()</code>","text":"<p>This function returns a Groovy Map summarizing parameters/workflow options used by the pipeline. As above, it only returns the provided parameters that are different to the default values.</p> <p>This function takes the same arguments as <code>paramsSummaryLog()</code>: the <code>workflow</code> object and an optional schema file path.</p> <p>Note</p> <p>Parameters which don't have a default in the JSON Schema and which have a value of <code>null</code>, <code>\"\"</code>, <code>false</code> or <code>'false'</code> won't be returned in the map.</p> <p>Typical usage:</p> main.nfnextflow.confignextflow_schema.json <pre><code>include { paramsSummaryMap } from 'plugin/nf-schema'\n\nprintln paramsSummaryMap(workflow)\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  outdir = \"results\"\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$id\": \"https://raw.githubusercontent.com/nf-core/testpipeline/master/nextflow_schema.json\",\n    \"title\": \"nf-core/testpipeline pipeline parameters\",\n    \"description\": \"this is a test\",\n    \"type\": \"object\",\n    \"$defs\": {\n        \"input_output_options\": {\n            \"title\": \"Input/output options\",\n            \"type\": \"object\",\n            \"fa_icon\": \"fas fa-terminal\",\n            \"description\": \"Define where the pipeline should find input data and save output data.\",\n            \"required\": [\"input\", \"outdir\"],\n            \"properties\": {\n                \"input\": {\n                    \"type\": \"string\",\n                    \"format\": \"file-path\",\n                    \"mimetype\": \"text/csv\",\n                    \"schema\": \"assets/schema_input.json\",\n                    \"pattern\": \"^\\\\S+\\\\.(csv|tsv|yaml|json)$\",\n                    \"description\": \"Path to comma-separated file containing information about the samples in the experiment.\",\n                    \"help_text\": \"You will need to create a design file with information about the samples in your experiment before running the pipeline. Use this parameter to specify its location. It has to be a comma-separated file with 3 columns, and a header row. See [usage docs](https://nf-co.re/testpipeline/usage#samplesheet-input).\",\n                    \"fa_icon\": \"fas fa-file-csv\"\n                },\n                \"outdir\": {\n                    \"type\": \"string\",\n                    \"format\": \"directory-path\",\n                    \"description\": \"The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.\",\n                    \"fa_icon\": \"fas fa-folder-open\"\n                }\n            }\n        }\n    },\n    \"allOf\": [\n        {\n            \"$ref\": \"#/$defs/input_output_options\"\n        }\n    ]\n}\n</code></pre> <p>Output:</p> <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [happy_lamport] DSL2 - revision: c45338cd96\n\n[Core Nextflow options:[runName:happy_lamport, launchDir:/Users/ewels/GitHub/nextflow-io/nf-schema/examples/paramsSummaryMap, workDir:/Users/ewels/GitHub/nextflow-io/nf-schema/examples/paramsSummaryMap/work, projectDir:/Users/ewels/GitHub/nextflow-io/nf-schema/examples/paramsSummaryMap/pipeline, userName:ewels, profile:standard, configFiles:], Input/output options:[input:samplesheet.csv, outdir:results]]\n</code></pre>"},{"location":"parameters/validation/","title":"Validation of pipeline parameters","text":""},{"location":"parameters/validation/#validateparameters","title":"<code>validateParameters()</code>","text":"<p>This function takes all pipeline parameters and checks that they adhere to the specifications defined in the JSON Schema.</p> <ul> <li>It does not return anything, but logs errors or warnings indicating the parameters that failed to the command line.</li> <li>If any parameter validation has failed, it throws a <code>SchemaValidationException</code> exception to stop the pipeline.</li> <li>If any parameters in the schema reference a sample sheet schema with <code>schema</code>, that file is loaded and validated.</li> </ul> <p>The function takes two optional arguments:</p> <ul> <li>The filename of a JSON Schema file (optional, default: <code>nextflow_schema.json</code>). File paths should be relative to the root of the pipeline directory.</li> <li>A boolean to disable coloured outputs (optional, default: <code>false</code>). The output is coloured using ANSI escape codes by default.</li> </ul> <p>You can provide the parameters as follows:</p> <pre><code>validateParameters(parameters_schema: 'custom_nextflow_parameters.json', monochrome_logs: true)\n</code></pre> <p>Monochrome logs can also be set globally providing the parameter <code>--monochrome_logs</code> or adding <code>params.monochrome_logs = true</code> to a configuration file. The form <code>--monochromeLogs</code> is also supported.</p> <p>Tip</p> <p>As much of the Nextflow ecosystem assumes the <code>nextflow_schema.json</code> filename, it's recommended to stick with the default, if possible.</p> <p>See the Schema specification for information about what validation data you can encode within the schema for each parameter.</p>"},{"location":"parameters/validation/#example","title":"Example","text":"<p>The example below has a deliberate typo in <code>params.input</code> (<code>.txt</code> instead of <code>.csv</code>). The validation function catches this for two reasons:</p> <ul> <li>The filename doesn't match the expected pattern (here checking file extensions)</li> <li>The supplied file doesn't exist</li> </ul> <p>The function causes Nextflow to exit immediately with an error.</p>  Outputmain.nfnextflow.confignextflow_schema.json <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [amazing_crick] DSL2 - revision: 53bd9eac20\n\nERROR ~ Validation of pipeline parameters failed!\n\n -- Check '.nextflow.log' file for details\nThe following invalid input values have been detected:\n\n* --input (samplesheet.txt): \"samplesheet.txt\" does not match regular expression [^\\S+\\.(csv|tsv|yml|yaml)$]\n* --input (samplesheet.txt): the file or directory 'samplesheet.txt' does not exist\n</code></pre> <pre><code>include { validateParameters } from 'plugin/nf-schema'\n\nvalidateParameters()\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.txt\"\n  outdir = \"results\"\n}\n</code></pre> <pre><code>{\n    \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n    \"$id\": \"https://raw.githubusercontent.com/nf-core/testpipeline/master/nextflow_schema.json\",\n    \"title\": \"nf-core/testpipeline pipeline parameters\",\n    \"description\": \"this is a test\",\n    \"type\": \"object\",\n    \"$defs\": {\n        \"input_output_options\": {\n            \"title\": \"Input/output options\",\n            \"type\": \"object\",\n            \"fa_icon\": \"fas fa-terminal\",\n            \"description\": \"Define where the pipeline should find input data and save output data.\",\n            \"required\": [\"input\", \"outdir\"],\n            \"properties\": {\n                \"input\": {\n                    \"type\": \"string\",\n                    \"format\": \"file-path\",\n                    \"mimetype\": \"text/csv\",\n                    \"schema\": \"assets/schema_input.json\",\n                    \"pattern\": \"^\\\\S+\\\\.(csv|tsv|yaml|json)$\",\n                    \"exists\": true,\n                    \"description\": \"Path to comma-separated file containing information about the samples in the experiment.\",\n                    \"help_text\": \"You will need to create a design file with information about the samples in your experiment before running the pipeline. Use this parameter to specify its location. It has to be a comma-separated file with 3 columns, and a header row. See [usage docs](https://nf-co.re/testpipeline/usage#samplesheet-input).\",\n                    \"fa_icon\": \"fas fa-file-csv\"\n                },\n                \"outdir\": {\n                    \"type\": \"string\",\n                    \"format\": \"directory-path\",\n                    \"description\": \"The output directory where the results will be saved. You have to use absolute paths to storage on Cloud infrastructure.\",\n                    \"fa_icon\": \"fas fa-folder-open\"\n                }\n            }\n        }\n    },\n    \"allOf\": [\n        {\n            \"$ref\": \"#/$defs/input_output_options\"\n        }\n    ]\n}\n</code></pre>"},{"location":"parameters/validation/#ignoring-parameters","title":"Ignoring Parameters","text":"<p>Users can turn off validation for specific parameters using <code>validation.ignoreParams</code>, which accepts a list of parameter names.</p>"},{"location":"parameters/validation/#failing-for-unrecognized-parameters","title":"Failing for unrecognized parameters","text":"<p>When parameters which are not specified in the JSON Schema are provided, the parameter validation function returns a <code>WARNING</code>. This is because user-specific institutional configuration profiles may make use of params that are unknown to the pipeline.</p> <p>The down-side of this is that warnings about typos in parameters can go unnoticed.</p> <p>To force the pipeline execution to fail with an error instead, you can provide the <code>validation.failUnrecognisedParams = true</code> configuration option:</p>  Default Fail unrecognised params Outputnextflow.configmain.nf <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [jovial_linnaeus] DSL2 - revision: 53bd9eac20\n\nWARN: The following invalid input values have been detected:\n\n* --foo: bar\n\nHello World!\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  outdir = \"results\"\n  foo = \"bar\"\n}\n</code></pre> <pre><code>include { validateParameters } from 'plugin/nf-schema'\n\nvalidateParameters()\n\nprintln \"Hello World!\"\n</code></pre> Outputnextflow.configmain.nf <pre><code>N E X T F L O W  ~  version 23.04.1\nLaunching `pipeline/main.nf` [pedantic_descartes] DSL2 - revision: 53bd9eac20\n\nERROR ~ ERROR: Validation of pipeline parameters failed!\n\n -- Check '.nextflow.log' file for details\nThe following invalid input values have been detected:\n\n* --foo: bar\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nvalidation.failUnrecognisedParams = true\n\nparams {\n  input = \"samplesheet.csv\"\n  outdir = \"results\"\n  foo = \"bar\"\n}\n</code></pre> <pre><code>include { validateParameters } from 'plugin/nf-schema'\n\nvalidateParameters()\n\nprintln \"Hello World!\"\n</code></pre>"},{"location":"parameters/validation/#ignoring-unrecognized-parameters","title":"Ignoring unrecognized parameters","text":"<p>Sometimes, a parameter that you want to set may not be described in the pipeline schema for a good reason. Maybe it's something you're using in your Nextflow configuration setup for your compute environment, or it's a complex parameter that cannot be handled in the schema, such as nested parameters.</p> <p>In these cases, to avoid getting warnings when an unrecognised parameter is set, you can use <code>--validationSchemaIgnoreParams</code> / <code>params.validationSchemaIgnoreParams</code>.</p> <p>This should be a comma-separated list of strings that correspond to parameter names.</p>"},{"location":"parameters/validation/#variable-type-checking","title":"Variable type checking","text":"<p>By default, <code>validateParameters()</code> is strict about expecting parameters to adhere to their expected type. If the schema says that <code>params.foo</code> should be an <code>integer</code> and the user sets <code>params.foo = \"12\"</code> (a string with a number), it will fail.</p> <p>If this causes problems, the user can run validation in \"lenient mode\", whereby the JSON Schema validation tries to cast parameters to their correct type. For example, providing an integer as a string will no longer fail validation.</p> <p>Note</p> <p>The validation does not affect the parameter variable types in your pipeline. It attempts to cast a temporary copy of the params only, during the validation step.</p> <p>To enable lenient validation mode, set <code>validation.lenientMode = true</code> in your configuration file.</p>"},{"location":"samplesheets/examples/","title":"Sample sheet channel manipulation examples","text":""},{"location":"samplesheets/examples/#introduction","title":"Introduction","text":"<p>Understanding channel structure and manipulation is critical for getting the most out of Nextflow. nf-schema helps initialise your channels from the text inputs to get you started, but further work might be required to fit your exact use case. In this page we run through some common cases for transforming the output of <code>samplesheetToList()</code>.</p>"},{"location":"samplesheets/examples/#glossary","title":"Glossary","text":"<ul> <li>A channel is the Nextflow object, referenced in the code</li> <li>An item is each thing passing through the channel, equivalent to one row in the sample sheet</li> <li>An element is each thing in the item, e.g., the meta value, fastq_1 etc. It may be a file or value</li> </ul>"},{"location":"samplesheets/examples/#default-mode","title":"Default mode","text":"<p>Each item in the list emitted by <code>samplesheetToList()</code> is a tuple, corresponding with each row of the sample sheet. Each item will be composed of a meta value (if present) and any additional elements from columns in the sample sheet, e.g.:</p> <pre><code>sample,fastq_1,fastq_2,bed\nsample1,fastq1.R1.fq.gz,fastq1.R2.fq.gz,sample1.bed\nsample2,fastq2.R1.fq.gz,fastq2.R2.fq.gz,\n</code></pre> <p>Might create a list where each element consists of 4 items, a map value followed by three files:</p> <pre><code>// Columns:\n[ val([ sample: sample ]), file(fastq1), file(fastq2), file(bed) ]\n\n// Resulting in:\n[ [ id: \"sample\" ], fastq1.R1.fq.gz, fastq1.R2.fq.gz, sample1.bed]\n[ [ id: \"sample2\" ], fastq2.R1.fq.gz, fastq2.R2.fq.gz, [] ] // A missing value from the sample sheet is an empty list\n</code></pre> <p>This list can be converted to a channel that can be used as input of a process where the input declaration is:</p> <pre><code>tuple val(meta), path(fastq_1), path(fastq_2), path(bed)\n</code></pre> <p>It may be necessary to manipulate this channel to fit your process inputs. For more documentation, check out the Nextflow operator docs, however here are some common use cases with <code>samplesheetToList()</code>.</p>"},{"location":"samplesheets/examples/#using-a-sample-sheet-with-no-headers","title":"Using a sample sheet with no headers","text":"<p>Sometimes you only have one possible input in the pipeline sample sheet. In this case it doesn't make sense to have a header in the sample sheet. This can be done by removing the <code>properties</code> section from the sample sheet and changing the type of the element from <code>object</code> the desired type:</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"description\": \"Schema for the file provided with params.input\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"string\"\n  }\n}\n</code></pre> <p>When using samplesheets like this CSV file:</p> <pre><code>test_1\ntest_2\n</code></pre> <p>or this YAML file:</p> <pre><code>- test_1\n- test_2\n</code></pre> <p>The output of <code>samplesheetToList()</code> will look like this:</p> <pre><code>test_1\ntest_2\n</code></pre>"},{"location":"samplesheets/examples/#changing-the-structure-of-channel-items","title":"Changing the structure of channel items","text":"<p>Each item in the list will be a tuple, but some processes will use multiple files as a list in their input channel, this is common in nf-core modules. For example, consider the following input declaration in a process, where FASTQ could be &gt; 1 file:</p> <pre><code>process ZCAT_FASTQS {\n    input:\n        tuple val(meta), path(fastq)\n\n    \"\"\"\n    zcat $fastq\n    \"\"\"\n}\n</code></pre> <p>The output of <code>samplesheetToList()</code> (converted to a channel) can be used by default with a process with the following input declaration:</p> <pre><code>val(meta), path(fastq_1), path(fastq_2)\n</code></pre> <p>To manipulate each item within a channel, you should use the Nextflow <code>.map()</code> operator. This will apply a function to each element of the channel in turn. Here, we convert the flat tuple into a tuple composed of a meta and a list of FASTQ files:</p> <pre><code>Channel.fromList(samplesheetToList(params.input, \"path/to/json/schema\"))\n    .map { meta, fastq_1, fastq_2 -&gt; tuple(meta, [ fastq_1, fastq_2 ]) }\n    .set { input }\n\ninput.view() // Channel has 2 elements: meta, fastqs\n</code></pre> <p>This is now compatible with the process defined above and will not raise a warning about input cardinality:</p> <pre><code>ZCAT_FASTQS(input)\n</code></pre>"},{"location":"samplesheets/examples/#removing-elements-in-channel-items","title":"Removing elements in channel items","text":"<p>For example, to remove the BED file from the channel created above, we could not return it from the map. Note the absence of the <code>bed</code> item in the return of the closure below:</p> <pre><code>Channel.fromList(samplesheetToList(params.input, \"path/to/json/schema\"))\n    .map { meta, fastq_1, fastq_2, bed -&gt; tuple(meta, fastq_1, fastq_2) }\n    .set { input }\n\ninput.view() // Channel has 3 elements: meta, fastq_1, fastq_2\n</code></pre> <p>In this way you can drop items from a channel.</p>"},{"location":"samplesheets/examples/#separating-channel-items","title":"Separating channel items","text":"<p>We could perform this twice to create one channel containing the FASTQs and one containing the BED files, however Nextflow has a native operator to separate channels called <code>.multiMap()</code>. Here, we separate the FASTQs and BEDs into two separate channels using <code>multiMap</code>. Note, the channels are both contained in <code>input</code> and accessed as an attribute using dot notation:</p> <pre><code>Channel.fromList(samplesheetToList(params.input, \"path/to/json/schema\"))\n    .multiMap { meta, fastq_1, fastq_2, bed -&gt;\n        fastq: tuple(meta, fastq_1, fastq_2)\n        bed:   tuple(meta, bed)\n    }\n    .set { input }\n</code></pre> <p>The channel has two attributes, <code>fastq</code> and <code>bed</code>, which can be accessed separately.</p> <pre><code>input.fastq.view() // Channel has 3 elements: meta, fastq_1, fastq_2\ninput.bed.view()   // Channel has 2 elements: meta, bed\n</code></pre> <p>Importantly, <code>multiMap</code> applies to every item in the channel and returns an item to both channels for every input, i.e. <code>input</code>, <code>input.fastq</code> and <code>input.bed</code> all contain the same number of items, however each item will be different.</p>"},{"location":"samplesheets/examples/#separate-items-based-on-a-condition","title":"Separate items based on a condition","text":"<p>You can use the <code>.branch()</code> operator to separate the channel entries based on a condition. This is especially useful when you can get multiple types of input data.</p> <p>This example shows a channel which can have entries for WES or WGS data. WES data includes a BED file denoting the target regions, but WGS data does not. These analysis are different so we want to separate the WES and WGS entries from each other. We can separate the two using <code>.branch</code> based on the presence of the BED file:</p> <pre><code>// Channel with four elements - see docs for examples\nparams.input = \"samplesheet.csv\"\n\nChannel.fromList(samplesheetToList(params.input, \"path/to/json/schema\"))\n    .branch { meta, fastq_1, fastq_2, bed -&gt;\n        // If BED does not exist\n        WGS: !bed\n            return [meta, fastq_1, fastq_2]\n        // If BED exists\n        WES: bed\n            // The original channel structure will be used when no return statement is used.\n    }\n    .set { input }\n\ninput.WGS.view() // Channel has 3 elements: meta, fastq_1, fastq_2\ninput.WES.view() // Channel has 4 elements: meta, fastq_1, fastq_2, bed\n</code></pre> <p>Unlike <code>.multiMap()</code>, the outputs of <code>.branch()</code> will contain a different number of items.</p>"},{"location":"samplesheets/examples/#combining-a-channel","title":"Combining a channel","text":"<p>After splitting the channel, it may be necessary to rejoin the channel. There are many ways to join a channel, but here we will demonstrate the simplest which uses the Nextflow join operator to rejoin any of the channels from above based on the first element in each item, the <code>meta</code> value.</p> <pre><code>input.fastq.view() // Channel has 3 elements: meta, fastq_1, fastq_2\ninput.bed.view()   // Channel has 2 elements: meta, bed\n\ninput.fastq\n    .join( input.bed )\n    .set { input_joined }\n\ninput_joined.view() // Channel has 4 elements: meta, fastq_1, fastq_2, bed\n</code></pre>"},{"location":"samplesheets/examples/#count-items-with-a-common-value","title":"Count items with a common value","text":"<p>This example is based on this code from Marcel Ribeiro-Dantas.</p> <p>It's useful to determine the count of channel entries with similar values when you want to merge them later on (to prevent pipeline bottlenecks with <code>.groupTuple()</code>).</p> <p>This example contains a channel where multiple samples can be in the same family. Later on in the pipeline we want to merge the analyzed files so one file gets created for each family. The result will be a channel with an extra meta field containing the count of channel entries with the same family name.</p> <pre><code>// channel created with samplesheetToList() previous to modification:\n// [[id:example1, family:family1], example1.txt]\n// [[id:example2, family:family1], example2.txt]\n// [[id:example3, family:family2], example3.txt]\n\nparams.input = \"sample sheet.csv\"\n\nChannel.fromList(samplesheetToList(params.input, \"path/to/json/schema\"))\n    .tap { ch_raw }                       // Create a copy of the original channel\n    .map { meta, txt -&gt; [ meta.family ] } // Isolate the value to count on\n    .reduce([:]) { counts, family -&gt;      // Creates a map like this: [family1:2, family2:1]\n        counts[family] = (counts[family] ?: 0) + 1\n        counts\n    }\n    .combine(ch_raw)                     // Add the count map to the original channel\n    .map { counts, meta, txt -&gt;          // Add the counts of the current family to the meta\n        new_meta = meta + [count:counts[meta.family]]\n        [ new_meta, txt ]\n    }\n    .set { input }\n\ninput.view()\n// [[id:example1, family:family1, count:2], example1.txt]\n// [[id:example2, family:family1, count:2], example2.txt]\n// [[id:example3, family:family2, count:1], example3.txt]\n</code></pre>"},{"location":"samplesheets/samplesheetToList/","title":"Create a list from a sample sheet","text":""},{"location":"samplesheets/samplesheetToList/#samplesheettolist","title":"<code>samplesheetToList()</code>","text":"<p>This function validates and converts a sample sheet to a Groovy list. This is done using information encoded within a sample sheet schema (see the docs).</p> <p>The function has two required arguments:</p> <ol> <li>The path to the samplesheet</li> <li>The path to the JSON schema file corresponding to the samplesheet.</li> </ol> <p>These can be either a string with the relative path (from the root of the pipeline) or a file object of the schema.</p> <pre><code>samplesheetToList(\"path/to/samplesheet\", \"path/to/json/schema\")\n</code></pre> <p>Note</p> <p>All data points in the CSV and TSV samplesheets will be converted to their derived type. (e.g. <code>\"true\"</code> will be converted to the Boolean <code>true</code> and <code>\"2\"</code> will be converted to the Integer <code>2</code>). You can still convert these types back to a String if this is not the expected behaviour with <code>.map { val -&gt; val.toString() }</code></p> <p>This function can be used together with existing channel factories/operators to create one channel entry per samplesheet entry.</p>"},{"location":"samplesheets/samplesheetToList/#use-as-a-channel-factory","title":"Use as a channel factory","text":"<p>The function can be used with the <code>.fromList</code> channel factory to generate a queue channel:</p> <pre><code>Channel.fromList(samplesheetToList(\"path/to/samplesheet\", \"path/to/json/schema\"))\n</code></pre> <p>Note</p> <p>This will mimic the <code>fromSamplesheet</code> channel factory, found in the previous nf-validation.</p>"},{"location":"samplesheets/samplesheetToList/#use-as-a-channel-operator","title":"Use as a channel operator","text":"<p>Alternatively, the function can be used with the <code>.flatMap</code> channel operator to create a channel from samplesheet paths that are already in a channel:</p> <pre><code>Channel.of(\"path/to/samplesheet\").flatMap { samplesheetToList(it, \"path/to/json/schema\") }\n</code></pre>"},{"location":"samplesheets/samplesheetToList/#basic-example","title":"Basic example","text":"<p>In this example, we create a simple channel from a CSV sample sheet.</p> <pre><code>N E X T F L O W  ~  version 23.04.0\nLaunching `pipeline/main.nf` [distraught_marconi] DSL2 - revision: 74f697a0d9\n[mysample1, input1_R1.fq.gz, input1_R2.fq.gz, forward]\n[mysample2, input2_R1.fq.gz, input2_R2.fq.gz, forward]\n</code></pre> main.nfsamplesheet.csvnextflow.configassets/schema_input.json <pre><code>include { samplesheetToList } from 'plugin/nf-schema'\n\nch_input = Channel.fromList(samplesheetToList(params.input, \"assets/schema_input.json\"))\n\nch_input.view()\n</code></pre> <pre><code>sample,fastq_1,fastq_2,strandedness\nmysample1,input1_R1.fq.gz,input1_R2.fq.gz,forward\nmysample2,input2_R1.fq.gz,input2_R2.fq.gz,forward\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  output = \"results\"\n}\n</code></pre> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/nf-schema/example/master/assets/schema_input.json\",\n  \"title\": \"nf-schema example - params.input schema\",\n  \"description\": \"Schema for the file provided with params.input\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"sample\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+$\",\n        \"errorMessage\": \"Sample name must be provided and cannot contain spaces\"\n      },\n      \"fastq_1\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\",\n        \"errorMessage\": \"FastQ file for reads 1 must be provided, cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\"\n      },\n      \"fastq_2\": {\n        \"errorMessage\": \"FastQ file for reads 2 cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\",\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\"\n      },\n      \"strandedness\": {\n        \"type\": \"string\",\n        \"errorMessage\": \"Strandedness must be provided and be one of 'forward', 'reverse' or 'unstranded'\",\n        \"enum\": [\"forward\", \"reverse\", \"unstranded\"]\n      }\n    },\n    \"required\": [\"sample\", \"fastq_1\", \"strandedness\"]\n  }\n}\n</code></pre>"},{"location":"samplesheets/samplesheetToList/#order-of-fields","title":"Order of fields","text":"<p>This example demonstrates that the order of columns in the sample sheet file has no effect.</p> <p>Danger</p> <p>It is the order of fields in the sample sheet JSON schema which defines the order of items in the channel returned by <code>samplesheetToList()</code>, not the order of fields in the sample sheet file.</p> <pre><code>N E X T F L O W  ~  version 23.04.0\nLaunching `pipeline/main.nf` [elated_kowalevski] DSL2 - revision: 74f697a0d9\n[forward, mysample1, input1_R2.fq.gz, input1_R1.fq.gz]\n[forward, mysample2, input2_R2.fq.gz, input2_R1.fq.gz]\n</code></pre> samplesheet.csvassets/schema_input.jsonmain.nfnextflow.config <pre><code>sample,fastq_1,fastq_2,strandedness\nmysample1,input1_R1.fq.gz,input1_R2.fq.gz,forward\nmysample2,input2_R1.fq.gz,input2_R2.fq.gz,forward\n</code></pre> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/nf-schema/example/master/assets/schema_input.json\",\n  \"title\": \"nf-schema example - params.input schema\",\n  \"description\": \"Schema for the file provided with params.input\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"strandedness\": {\n        \"type\": \"string\",\n        \"errorMessage\": \"Strandedness must be provided and be one of 'forward', 'reverse' or 'unstranded'\",\n        \"enum\": [\"forward\", \"reverse\", \"unstranded\"]\n      },\n      \"sample\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+$\",\n        \"errorMessage\": \"Sample name must be provided and cannot contain spaces\"\n      },\n      \"fastq_2\": {\n        \"errorMessage\": \"FastQ file for reads 2 cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\",\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\"\n      },\n      \"fastq_1\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\",\n        \"errorMessage\": \"FastQ file for reads 1 must be provided, cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\"\n      }\n    },\n    \"required\": [\"sample\", \"fastq_1\", \"strandedness\"]\n  }\n}\n</code></pre> <pre><code>include { samplesheetToList } from 'plugin/nf-schema'\n\nch_input = Channel.fromList(samplesheetToList(params.input, \"assets/schema_input.json\"))\n\nch_input.view()\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  output = \"results\"\n}\n</code></pre>"},{"location":"samplesheets/samplesheetToList/#channel-with-meta-map","title":"Channel with meta map","text":"<p>In this example, we use the schema to mark two columns as meta fields. This returns a channel with a meta map.</p> <pre><code>N E X T F L O W  ~  version 23.04.0\nLaunching `pipeline/main.nf` [romantic_kare] DSL2 - revision: 74f697a0d9\n[[my_sample_id:mysample1, my_strandedness:forward], input1_R1.fq.gz, input1_R2.fq.gz]\n[[my_sample_id:mysample2, my_strandedness:forward], input2_R1.fq.gz, input2_R2.fq.gz]\n</code></pre> assets/schema_input.jsonmain.nfsamplesheet.csvnextflow.config <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://raw.githubusercontent.com/nf-schema/example/master/assets/schema_input.json\",\n  \"title\": \"nf-schema example - params.input schema\",\n  \"description\": \"Schema for the file provided with params.input\",\n  \"type\": \"array\",\n  \"items\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"sample\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+$\",\n        \"errorMessage\": \"Sample name must be provided and cannot contain spaces\",\n        \"meta\": [\"my_sample_id\"]\n      },\n      \"fastq_1\": {\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\",\n        \"errorMessage\": \"FastQ file for reads 1 must be provided, cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\"\n      },\n      \"fastq_2\": {\n        \"errorMessage\": \"FastQ file for reads 2 cannot contain spaces and must have extension '.fq.gz' or '.fastq.gz'\",\n        \"type\": \"string\",\n        \"pattern\": \"^\\\\S+\\\\.f(ast)?q\\\\.gz$\"\n      },\n      \"strandedness\": {\n        \"type\": \"string\",\n        \"errorMessage\": \"Strandedness must be provided and be one of 'forward', 'reverse' or 'unstranded'\",\n        \"enum\": [\"forward\", \"reverse\", \"unstranded\"],\n        \"meta\": [\"my_strandedness\"]\n      }\n    },\n    \"required\": [\"sample\", \"fastq_1\", \"strandedness\"]\n  }\n}\n</code></pre> <pre><code>include { samplesheetToList } from 'plugin/nf-schema'\n\nch_input = Channel.fromList(samplesheetToList(params.input, \"assets/schema_input.json\"))\n\nch_input.view()\n</code></pre> <pre><code>sample,fastq_1,fastq_2,strandedness\nmysample1,input1_R1.fq.gz,input1_R2.fq.gz,forward\nmysample2,input2_R1.fq.gz,input2_R2.fq.gz,forward\n</code></pre> <pre><code>plugins {\n  id 'nf-schema@2.0.0'\n}\n\nparams {\n  input = \"samplesheet.csv\"\n  output = \"results\"\n}\n</code></pre>"},{"location":"samplesheets/validate_sample_sheet/","title":"Validate a sample sheet file contents","text":"<p>When a parameter provides the <code>schema</code> field, the <code>validateParameters()</code> function will automatically parse and validate the provided file contents using this JSON schema. It can validate CSV, TSV, JSON and YAML files.</p> <p>The path of the schema file must be relative to the root of the pipeline directory. See an example in the <code>input</code> field from the example schema.json.</p> <pre><code>{\n  \"properties\": {\n    \"input\": {\n      \"type\": \"string\",\n      \"format\": \"file-path\",\n      \"pattern\": \"^\\\\S+\\\\.csv$\",\n      \"schema\": \"src/testResources/samplesheet_schema.json\",\n      \"description\": \"Path to comma-separated file containing information about the samples in the experiment.\"\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>The <code>samplesheetToList</code> function also validate the files before converting them. If you convert the samplesheet, it's not necessary to add a schema to the parameter corresponding to the samplesheet.</p> <p>For more information about the sample sheet JSON schema refer to sample sheet docs.</p>"},{"location":"validate/validate/","title":"Validate common data structures","text":"<p>The <code>validate</code> function can be used to validate common data structures.</p> <pre><code>include { validate } from 'plugin/nf-schema'\n\nvalidate(&lt;input&gt;, &lt;schema&gt;)\n</code></pre> <p>This function takes two positional arguments:</p> <ol> <li>The data that needs to be validated</li> <li>The path to the schema used to validate the input data</li> </ol> <p>The tested data structures are listed below, however more data structures might by supported too:</p> <ul> <li>Maps</li> <li>Lists</li> <li>String</li> <li>Integers</li> <li>Booleans</li> </ul> <p><code>validate</code> also has the following optional arguments:</p> <ul> <li><code>exitOnError</code>: Exit the pipeline on validation failure and show the error message. The function will output the errors when this option is set to <code>false</code> (default: <code>true</code>)</li> <li><code>validate(&lt;input&gt;, &lt;schema&gt;, exitOnError:true|false)</code></li> </ul>"}]}